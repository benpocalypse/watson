#!/usr/bin/env bash

######################################################################
#
# Watson version 1.0
#
# “It’s elementary, my dear…”
#
# Watson helps you set up your new elementary OS Vala app.
#
# For details, please see:
# https://github.com/small-tech/watson
#
# Follows the Community Bash Style Guide.
# https://github.com/azet/community_bash_style_guide
#
# Copyright ⓒ 2021-present Aral Balkan (https://ar.al)
# Small Technology Foundation (https://small-tech.org)
#
# Like this? Fund us!
# https://small-tech.org/fund-us
#
# Released under GNU GPL version 3.0.
#
######################################################################

# set -eu -o pipefail

function show_usage {
  echo 'Usage: watson [--dryrun|-d|--help|-h]'
}

function show_error {
  message=$1
  show_usage
  echo ''
  echo -e "❌ \033[41mERROR\033[0m ${message}"
  echo ''
  echo 'To use Watson:'
  echo ''
  echo '1. Go to https://github.com/small-tech/watson'
  echo '2. Press the green “Use this template” button to create a new repository from Watson.'
  echo '3. Clone your new repository.'
  echo '4. Switch to that repository.'
  echo '5. Run ./watson'
  exit
}

function show_help {
  show_usage
  exit
}

dryRun=false

# Get the GitHub details from git itself.
gitRemote=($(git remote -v 2> /dev/null))

# Ensure current directory is a git working copy.
if [[ "$?" == "128" ]]; then
  show_error 'The current directory is not a git working copy.'
fi

gitUrl=${gitRemote[1]}

# This regular expression extracts the organisation
# and app from a GitHub remote URL (works on both SSH
# and HTTPS URLs.)
gitUrlRegExp='.*?github\.com.(.*?)/(.*?)\.git'

# Execute the regular expression.
[[ $gitUrl =~ $gitUrlRegExp ]]

# Get the GitHub organisation and app name from the
# regular expression results.
github_organisation_original="${BASH_REMATCH[1]}"
github_app_original="${BASH_REMATCH[2]}"

# Ensure the developer hasn’t accidentally cloned
# The Watson repository instead of creating their own
# using the “use this template” button on GitHub to
# create their own repository based on Watson.
if [[ "${github_organisation_original}" == "small-tech" && "${github_app_original}" == "watson" ]]; then
  show_error 'You currently have the original Watson repository cloned.'
fi

function dry_run {
  dryRun=true
  echo '⧼⧼⧼⧼⧼ Dry run ⧽⧽⧽⧽⧽'
  echo ''
  echo "Carries out substitutions, presents diff, reverts changes, and exits."
}

# Apply flags, if any.
[[ $1 == '--dry-run' || $1 == '-d' ]] && dry_run
[[ $1 == '--help' || $1 == '-h' ]] && show_help

current_step=0
steps=('Install elementary OS development libaries' 'Install VSCodium extensions' 'Get GitHub details' 'App Details (1/2)' 'App Details (2/2)' 'Copyright Details' 'Parse responses' 'Perform substitutions' 'Rename files' 'Meson build' 'Create translations' 'Ninja build' 'Delete self' 'Commit and push changes' 'Exit')

# Trap errors and handle them gracefully.
#
# $1: Line number of error.
# $2: Exit code of command that failed.
function handle_error {
  printf "Step %d (%s)" $(( ${current_step} + 1 )) "${steps[${current_step}]}"
  if (( current_step > 2 && current_step < 6 )); then
    printf " cancelled.\n"
  else
    printf " failed on line $1.\n"
  fi
  exit $2
}
trap 'handle_error ${LINENO} $? ' ERR

# Constants

readonly copyright_year=$(date '+%Y')

# STEP 0: Install elementary OS development libraries (if necessary and desired).

elementary_sdk_status=$(/usr/bin/dpkg-query --show --showformat='${db:Status-Status}\n' 'elementary-sdk' 2> /dev/null)
if [[ $elementary_sdk_status != 'installed' ]]; then
  install_elementary_sdk_question=$(zenity --question --text='<big>The elementary OS development libraries are not installed.</big>\n\n<b>Install them now?</b>' --title='Watson' --width=250 --icon-name=applications-development)
  install_extensions=$?
  if [[ $install_extensions == 0 ]]; then
    sudo apt install elementary-sdk
  fi
else
  echo '✓ elementary OS development libraries found.'
fi

current_step=$(( current_step + 1 ))

# STEP 1: Install VSCodium extensions (if necessary and desired).

# Is VSCodium installed? If not, we don’t need to bother the person with this.
which_vscodium=$(which codium)
vscodium_exists=$?
if [[ ${vscodium_exists} == 0 ]]; then
  # VSCodium is installed. Are all the extensions already installed? If so,
  # we don’t need to bother the person with this.
  already_installed_extensions_count=$(codium --list-extensions | grep -E "prince781.vala|asabil.meson|vadimcn.vscode-lldb|redhat.vscode-xml|redhat.vscode-yaml" | wc -l)
  if [[ ${already_installed_extensions_count} != 5 ]]; then
    # VSCodium is installed but one or more of the extensions that would
    # make the person’s life easier aren’t. Ask the person if they’d
    # like to have Watson install them.
    install_extensions_question=$(zenity --question --text='<big>Install VSCodium extensions?</big>\n\n<i>(This will install the Vala, Meson, CodeLLDB debugger, XML, and YAML extensions. With the extensions installed, press F5 in VSCodium to run/debug your app.)</i>' --title='Watson' --width=250 --icon-name=extension)
    install_extensions=$?
    if [[ $install_extensions == 0 ]]; then
      # Vala
      # https://github.com/Prince781/vala-vscode
      codium --install-extension prince781.vala

      # Meson
      # https://github.com/asabil/vscode-meson
      codium --install-extension asabil.meson

      # CodeLLDB: a native debugger extension based on LLDB.
      # https://github.com/vadimcn/vscode-lldb
      codium --install-extension vadimcn.vscode-lldb

      # XML
      # https://github.com/redhat-developer/vscode-xml
      codium --install-extension redhat.vscode-xml

      # YAML
      # https://github.com/redhat-developer/vscode-yaml
      codium --install-extension redhat.vscode-yaml
    fi
  else
    echo '✓ VSCodium and all recommended extensions already installed.'
  fi
else
  echo 'ℹ️ VSCodium not installed; skipping recommended extensions check.'
fi

current_step=$(( current_step + 1 ))

# STEP 2: Get app details (1/2).

app_details_pipe_separated=$(zenity --forms --height=260 --title="Watson" --text="\n  <big><u>App details (1/2)</u></big>" --add-entry="Name:" --add-entry="Generic Name (e.g., Web Browser):" --add-entry="Description" --add-entry="Tooltip text (comment)" --add-entry="Keywords (separated;by;semicolons)")

current_step=$(( current_step + 1 ))

# STEP 3: Get app details (2/2) – categories (multi-select list).

app_categories=$(zenity --list --width=400 --height=460 --multiple --separator=";" --title="Watson" --text="\n  <big><u><b>App Details (2/2)</b></u></big>\n\n  <i>You may select more than one.\n</i>" --column="Category" "AudioVideo" "Audio" "Video" "Development" "Education" "Game" "Graphics" "Network" "Office" "Science" "Settings" "System" "Utility")

current_step=$(( current_step + 1 ))

# STEP 4: Get copyright details.

copyright_details_pipe_separated=$(zenity --forms --width=300 --title="Watson" --text="\n  <big><u>Copyright Details</u></big>  \n\n  <i>Copyright ⓒ ${copyright_year}-present <big>‹Name›</big> <big>‹Email›</big></i>\n" --add-entry="Name" --add-entry="Email")

current_step=$(( current_step + 1 ))

# STEP 5: Parse responses.

# Parse the pipe-separated results returned from the Zenity dialogues into bash arrays.
IFS='|' read -ra app_details <<< "${app_details_pipe_separated}"
IFS='|' read -ra copyright_details <<< "${copyright_details_pipe_separated}"

# We replace any dashes in the desktop entry names with underscores for
# compatibility with D-Bus names. See:
# https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s02.html
#
# TODO: Also handle edge case of names that begin with numbers? (Prefix with an underscore.)
github_organisation=${github_organisation_original//'-'/'_'}
github_app=${github_app_original//'-'/'_'}

app_name=${app_details[0]}
app_generic_name=${app_details[1]}
app_description=${app_details[2]}
app_comment=${app_details[3]}
app_keywords=${app_details[4]}

# The namespace is calculated by removing spaces from the app name.
# As app names are capitalised by convention, this should lead to a namespace
# that conforms to Vala naming conventions on elementary OS.
app_namespace=$(echo "${app_name}" | sed s/[[:space:]]//g)

copyright_name=${copyright_details[0]}
copyright_email=${copyright_details[1]}

current_step=$(( current_step + 1 ))

# STEP 6: Perform substitutions.

# This is the list of files to carry out substituions in.
# These files are all in the template/ directory.
files=('com.github.ORG.APP.yml' 'meson.build' 'README.md' 'src/Application.vala' 'data/APP.appdata.xml.in' 'data/APP.desktop.in' 'data/gresource.xml' 'data/gschema.xml' 'po/POTFILES' 'task/build' 'task/install' 'task/run' 'task/update-translations' '.github/workflows/main.yml' '.vscode/launch.json')

# Switch to the template directory.
pushd template

# Carry out substitutions in configuration files and source code.
for file in "${files[@]}"; do
  sed -i "s/{GITHUB.ORG}/${github_organisation}/g" "${file}"
  sed -i "s/{GITHUB.APP}/${github_app}/g" "${file}"
  sed -i "s/{APP.NAME}/${app_name}/g" "${file}"
  sed -i "s/{APP.GENERIC_NAME}/${app_generic_name}/g" "${file}"
  sed -i "s/{APP.DESCRIPTION}/${app_description}/g" "${file}"
  sed -i "s/{APP.COMMENT}/${app_comment}/g" "${file}"
  sed -i "s/{APP.CATEGORIES}/${app_categories}/g" "${file}"
  sed -i "s/{APP.KEYWORDS}/${app_keywords}/g" "${file}"
  sed -i "s/{COPYRIGHT.YEAR}/${copyright_year}/g" "${file}"
  sed -i "s/{COPYRIGHT.NAME}/${copyright_name}/g" "${file}"
  sed -i "s/{COPYRIGHT.EMAIL}/${copyright_email}/g" "${file}"
done

# Commit our changes (so we can always see a clean diff of the substitutions).
git add --all
git commit -m "Carry out template substitutions"

current_step=$(( current_step + 1 ))

# STEP 7: Rename files.

mv com.github.ORG.APP.yml "com.github.${github_organisation}.${github_app}.yml"
mv data/APP.appdata.xml.in "data/${github_app}.appdata.xml.in"
mv data/APP.desktop.in "data/${github_app}.desktop.in"

# Switch back to the main directory, move all the files in the
# template directory to the main directory (overriding Watson’s
# own README, CHANGELOG, .gitignore, etc., in the process), and
# delete the now-empty template directory, thereby leaving the
# new app ready to be built in the next step.
popd
mv template/* .
mv template/.vscode .
mv template/.github .
mv template/.editorconfig .
rm -r template

current_step=$(( current_step + 1 ))

# STEP 8: Meson build.

meson build --prefix=/usr

current_step=$(( current_step + 1 ))

# STEP 9: Create translations.

task/update-translations --no-status

current_step=$(( current_step + 1 ))

# Step 10: Ninja build.

task/build

current_step=$(( current_step + 1 ))

# Install app.

# When we have settings set up, we also have to
# run task/install before the app can run properly with
# settings enabled.

# TODO

# If this is a dry run (useful when developing/testing Watson itself),
# then display the git status and information on how to revert the changes,
# and exit without removing watson or replacing the git repository.
if ${dryRun}; then
  git status
  echo ''
  echo '⧼⧼⧼⧼⧼ Dry run: complete. ⧽⧽⧽⧽⧽'
  echo ''
  echo 'See changes:'
  echo 'git diff'
  echo ''
  echo 'Revert changes:'
  echo 'git reset --hard HEAD && git clean -d -f'
  exit
fi

# Step 11: Delete self (goodbye, cruel world!)

rm watson

current_step=$(( current_step + 1 ))

# Step 12: Commit and push changes.

git add --all
git commit -m "Finish customising app template"
git push

current_step=$(( current_step + 1 ))

# Step 13: Exit.

# That’s it! Goodbye :)
exit 0
